# Minimal Agent 设计说明（工程版）


## 1. Agent 的职责边界
- Agent 是控制器，不是工具。
- Agent 的职责是：把高层任务拆解为可执行步骤、选择合适能力执行、评估结果并把评估写回经验库。
- Agent 不做的事（刻意边界）：
	- 不直接操作敏感或生产系统数据；需要接入网关/审查层后才能执行实际写操作。
	- 不在执行层做质量判断（Execution 仅返回客观结果）。
	- 不承担复杂的长期会话/事务逻辑（这类逻辑应由上层服务或专用组件实现）。

## 2. 为什么 Planner 只拆 Step
- 单一职责：Planner 的任务是把不可执行的高层 Task 转为一组可逐步处理的 Steps。
- 解耦性：把 Planner 与 Decision 分离可让两边独立升级（例如替换为更强的 LLM 或规则引擎）。

## 3. 为什么 Decision 不执行 Tool
- 决策与执行分离带来可测试性和可解释性：Decision 只读 `State`，计算分数并选择工具，便于审计和调优。
- 如果 Decision 执行工具，会混淆责任并增加副作用风险。

## 4. 为什么 Tool 必须是被动的
- 无副作用原则：被动工具实现单次、可重入的能力调用（输入→输出），降低意外行为风险。
- 易于组合与 Mock：被动接口便于单元测试、并行执行与能力替换。

## 5. Reflection 为什么不能直接控制流程
- 单一写入口：Reflection 输出评估结果（`ReflectionDecision`），由 `State.apply_reflection` 将评估转化为经验统计。
- 将判断与控制分离能避免循环依赖，保证经验的可追溯性与一致性。

## 6. State 为什么是“经验载体”而不是缓存
- 语义化的数据：State 存储的是可用于决策的统计（`success`/`failure`/`streak`、失败原因画像），而非原始的工具缓存。
- 单一真源：经验仅由 `apply_reflection` 写入，避免执行阶段噪音影响长期经验。

## 7. 这个 Agent 能解决什么业务问题
- 自动化并编排流程化任务：把高层任务拆解、选择合适能力并汇总输出（如文案生成、FAQ 回答、流程建议）。
- 能力路由与容错：当某能力频繁失败时，Agent 会根据历史经验倾向其他更可靠的工具，降低整体失败率。
- 快速迭代：将能力以 `TOOL_MAP` 管理，便于替换或 A/B 测试能力实现。

## 8. 这个 Agent 刻意没做的事（设计取舍）
- 不做长期会话状态管理或复杂事务（这些应由专用组件处理）。
- 不直接操作敏感生产系统或进行权限决策。
- 不包含复杂的在线学习或模型训练流程；经验为可解释的简单统计和画像。
- 不替代领域专家：复杂业务判断仍需业务规则或人工决策。

---

如需，我可以把这些要点另存为 `README.md`，并加入示例运行与调试步骤（例如如何模拟某工具连续失败并观察决策切换）。
